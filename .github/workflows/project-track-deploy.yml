name: Project Track Deploy (Stage & Master)

on:
  pull_request:
    types: [closed]

permissions:
  contents: read
  pull-requests: read
  issues: write
  projects: write

jobs:
  track_deploy:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            const base = pr.base.ref; // branch alvo do PR (ex.: stage ou master)
            const body = pr.body || "";

            // === CONFIG ===
            const ORG = "Fiestou";
            const PROJECT_NUMBER = 1;
            const STATUS_FIELD = "Status";

            const TO_TESTING = "Testing";        // quando merge em stage
            const TO_DONE    = "Done";           // quando merge em master
            // Opcional: outro campo single-select "Ambiente" para marcar onde está
            const ENV_FIELD  = "Ambiente";       // crie no Project (opcional). Ex.: "Stage", "Produção"
            const ENV_STAGE  = "Stage";
            const ENV_PROD   = "Produção";
            // =============

            // Issues ligadas via Closes #N
            const issueNums = [...body.matchAll(/(close[sd]?|fix(e[sd])?|resolve[sd]?)\s+#(\d+)/ig)].map(m => Number(m[3]));
            if (issueNums.length === 0) { core.info("PR merged sem 'Closes #N'. Nada a mover."); return; }

            const gql = (q, v) => github.graphql(q, v);

            const { organization: { projectV2 } } = await gql(`
              query($org:String!, $num:Int!) {
                organization(login:$org) {
                  projectV2(number:$num) {
                    id
                    fields(first:50) {
                      nodes {
                        ... on ProjectV2SingleSelectField {
                          __typename
                          id
                          name
                          options { id name }
                        }
                      }
                    }
                  }
                }
              }
            `, { org: ORG, num: PROJECT_NUMBER });

            const getField = (name) => projectV2.fields.nodes.find(f => f && f.name === name);
            const statusField = getField(STATUS_FIELD);
            const envField    = getField(ENV_FIELD);

            const optId = (field, name) => !field ? null : field.options.find(o => o.name === name)?.id;

            const statusTo =
              base === "stage"  ? optId(statusField, TO_TESTING) :
              base === "master" ? optId(statusField, TO_DONE)    : null;

            const envTo =
              base === "stage"  ? optId(envField, ENV_STAGE) :
              base === "master" ? optId(envField, ENV_PROD)  : null;

            const updateSingleSelect = async (itemId, field, optionId) => {
              if (!field || !optionId) return;
              await gql(`
                mutation($projectId:ID!,$itemId:ID!,$fieldId:ID!,$opt:String!){
                  updateProjectV2ItemFieldValue(input:{
                    projectId:$projectId,
                    itemId:$itemId,
                    fieldId:$fieldId,
                    value:{ singleSelectOptionId:$opt }
                  }) { clientMutationId }
                }
              `, { projectId: projectV2.id, itemId, fieldId: field.id, opt: optionId });
            };

            for (const n of issueNums) {
              const { repository: { issue } } = await gql(`
                query($owner:String!,$repo:String!,$n:Int!){
                  repository(owner:$owner, name:$repo){ issue(number:$n){ id } }
                }
              `, { owner: context.repo.owner, repo: context.repo.repo, n });

              if (!issue) continue;

              const addRes = await gql(`
                mutation($projectId:ID!,$contentId:ID!){
                  addProjectV2ItemById(input:{projectId:$projectId, contentId:$contentId}) {
                    item { id }
                  }
                }
              `, { projectId: projectV2.id, contentId: issue.id });

              const itemId = addRes.addProjectV2ItemById.item.id;

              await updateSingleSelect(itemId, statusField, statusTo);
              await updateSingleSelect(itemId, envField, envTo);

              core.info(`Issue #${n} atualizada por merge em '${base}'.`);
            }
